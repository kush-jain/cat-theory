"""
https://bartoszmilewski.com/2014/12/05/categories-great-and-small/

Notes:
    1. Categories Types:
        A. Empty category
        B. Free category (Generated by a directed graph by adding minimum required items to satisfy category laws)
        C. Orders: Category where morphism is relation between objects
            i. Pre-order
                (Relation of being less than or equal)
                Cycles are allowed in pre-order. (Possible if a<=b, b<=a, but a!=b)
            ii. Partial order
                if (a<=b and b<=a) then a must be equal to b.
                Cycles are not allowed.
                Can be sorted via topological sort
            iii. Linear Order/Total Order
                If you have a condition such that any two objects within category are in relation with each other
                Sorting algorithms such as Bubble Sort, Insertion Sort, Quick-sort, Merge sort all work
            iv. Thin Order
                At most one morphism from one object to another (Example: Pre-order)
        D. Monoid (explained below)
    2. Hom-set
        Way of representing set of morphisms from a to b in category C
        Represented by: C(a, b)
        Eg: all C(x, y) for pre-order must either be singleton or empty set
    3. Monoid as Set
        Monoid is simply a set with a binary operation such that this operation is associative and there is an identity
        element in a set.

        For example:
            For all natural numbers form monoid under addition as:
                i. (a + b) + c = a + (b + c)
                ii. x + 0 = x (for any x)

            Product (with 1 as unit)
            String Concatenation (empty string is identity element)

        Haskell Definition:

            class Monoid m where
                mempty  :: m
                mappend :: m -> m -> m

            instance Monoid String where
                mempty = ""
                mappend = (++)

            "Hello " ++ "world!"

        Python Definition

            class Monoid:
                def __init__(self, mempty, mappend):
                    self.mempty = mempty
                    self.mappend = mappend

                def __call__(self, *args):
                    arg_lens = len(args)
                    if not arg_lens:
                        raise Exception("Need at least one argument")
                    elif arg_lens == 1:
                        return self.mappend(args[0], self.mempty)
                    else:
                        return self.mappend(args[0], self.__call__(*args[1:]))

            concat = Monoid("", lambda x, y: x+y)
            concat("Hello ", "World")

    4. Monoid as Category
        Monoid can be thought of as single object category with set of morphisms that follow composition rules.

        Converting from Set to Category
            Take Adders for example.
            Your Category object would be the set you are considering (Eg: Natural numbers)
            Your morphisms are Different Adders, for example Adder 5 (Morphs A-> A+5)
            Since monoid set is associative, all such morphisms would follow composition rule

        Converting from Category to Set
            From our single object category M with element m, select different morphisms
            These morphisms can be represented via Hom-set f->M(m, m), g->M(m, m)
            The product is f.g and by nature is associative
            Identity morphism is neutral element of set
"""

from __future__ import unicode_literals


"""
Challenges:

1.
Generate a free category from:
    1. A graph with one node and no edges
    2. A graph with one node and one (directed) edge (hint: this edge can be composed with itself)
    3. A graph with two nodes and a single arrow between them
    4. A graph with a single node and 26 arrows marked with the letters of the alphabet: a, b, c ... z.

2.
What kind of order is this?
    1. A set of sets with the inclusion relation: A is included in B if every element of A is also an element of B.
    2. C++ types with the following subtyping relation: T1 is a subtype of T2 if a pointer to T1 can be passed to a function that expects a pointer to T2 without triggering a compilation error.

3
Considering that Bool is a set of two values True and False, show that it forms two (set-theoretical) monoids with respect to, respectively, operator && (AND) and || (OR).

4.
Represent the Bool monoid with the AND operator as a category: List the morphisms and their rules of composition.

5.
Represent addition modulo 3 as a monoid category.
"""

